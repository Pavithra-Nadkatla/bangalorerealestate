# -*- coding: utf-8 -*-
"""bglr house prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MDOr4g80g_32MN05XAriw0nDXOWsc19G

## **Importing libraries required**
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

"""# **Data Load to Dataframe**"""

#data set taken from kaggle and reading it
df1=pd.read_csv('/content/bengaluru_house_prices.csv')
df1.head()



df1.shape

df1.columns

df1.area_type.value_counts()

"""## **Drop few columns**"""

df2 = df1.drop(['area_type','society','balcony','availability'],axis='columns')
df2.shape

"""# **Checking for null values**"""

df2.isnull().sum()

df3=df2.dropna()
df3.isnull().sum()

"""# **Feature Engineering**"""

df3['bhk']=df3['size'].str.split(' ').str[0]#redefining size column

df3['bhk']=df3['bhk'].astype(int)
df3['bhk'].unique()

"""**Covert all the values in total sq ft column to float**"""

def convert_to_num(value):
    if isinstance(value, float):
        return value
    elif isinstance(value, int):
        return float(value)
    elif isinstance(value, str):
        if '-' in value:
            start, end = map(float, value.split('-'))
            return (start + end) / 2
        else:
            try:
                return float(value)
            except ValueError:
                return None
    else:
        return None


df3['total_sqft'] = df3['total_sqft'].apply(convert_to_num)

df3['total_sqft'].dtypes

df4 = df3.copy()
df4['price_per_sqft'] = df4['price']*100000/df4['total_sqft']
df4.head()

"""Since there are so many location, we will try to reduce them by tagging them as 'others' wherever there are less than 10 data points"""

location_stats = df4['location'].value_counts(ascending=False)
location_stats.astype(float)

location_stas_less_than_10 = location_stats[location_stats < 10]
location_stas_less_than_10

df4.location = df4.location.apply(lambda x : 'other' if x in location_stas_less_than_10 else x)

"""Considering 300 sqft for one bhk we shall remove outliers which are unusual"""

df4[df4.total_sqft/df4.bhk<300].head()

df5 = df4[~(df4.total_sqft/df4.bhk<300)]
df5.shape

# Boxplot for outlier analysis
plt.figure(figsize=(10,8))
plt.title('Boxplot for Numerical Variable')
df4.boxplot()

"""# **Removing outliers using std and mean method**"""

def remove_pps_outliers(df):
    df_out = pd.DataFrame()
    for key, subdf in df.groupby('location'):
        m = np.mean(subdf.price_per_sqft)
        st = np.std(subdf.price_per_sqft)
        reduced_df = subdf[(subdf.price_per_sqft>(m-st)) & (subdf.price_per_sqft<=(m+st))]
        df_out = pd.concat([df_out,reduced_df],ignore_index=True)
    return df_out

df6 = remove_pps_outliers(df5)
df6.shape

"""Considering 1 bathroom for 1 bhk in common assumption or max of two extra bathrooms we will remove data having bathrooms (BHK+2)"""

df7 = df6[df6.bath < df6.bhk+2]
df7.shape

df7 = df7.drop(['size','price_per_sqft'],axis='columns')
df7.head(3)

df7.location.value_counts()

df8=df7.copy()

"""# **Dummy Encoding of Categorical Variables**"""

dummies = pd.get_dummies(df8.location)

dummies = dummies.astype(int)
dummies.head(3)

df9 = pd.concat([df8,dummies.drop('other',axis='columns')],axis='columns')
df9

df10 = df9.drop('location',axis = 'columns')
df10.head(10)

df9.location.unique()

"""# **Model Training**"""

X = df10.drop(['price'],axis='columns')
y=df10.price

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.2,random_state=10)

from sklearn.linear_model import LinearRegression
model = LinearRegression()
model.fit(X_train,y_train)
model.score(X_test,y_test)

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# Predict y values using the trained model
y_pred = model.predict(X)

# Calculate performance metrics
mae = mean_absolute_error(y, y_pred)
mse = mean_squared_error(y, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y, y_pred)
# Print summary
print("Linear Regression Model Summary:")
print("Mean Absolute Error (MAE):", mae)
print("Mean Squared Error (MSE):", mse)
print("Root Mean Squared Error (RMSE):", rmse)
print("R-squared:", r2)

"""# **Prediction model**"""

# Function to preprocess user input and make predictions
def predict_price(location, total_sqft, bath, bhk):
    # Create a dataframe with the input features
    input_data = pd.DataFrame({
        'total_sqft': [total_sqft],
        'bath': [bath],
        'bhk': [bhk],
        location: [1]  # Assuming the location is one of the columns in your dataframe
    })
    # Use the trained model to make predictions
    predicted_price = model.predict(input_data)
    return predicted_price[0]

!pip install streamlit

import streamlit as st
import pandas as pd

# Function to preprocess user input and make predictions
def predict_price(location, total_sqft, bath, bhk):
    # Create a dataframe with the input features
    input_data = pd.DataFrame({
        'total_sqft': [total_sqft],
        'bath': [bath],
        'bhk': [bhk],
        location: [1]  # Assuming the location is one of the columns in your dataframe
    })
    # Use the trained model to make predictions
    predicted_price = model.predict(input_data)
    return predicted_price[0]

if __name__ == '__main__':
    st.title('Property Price Predictor')

    # Input fields
    location = st.text_input('Location', 'Enter location here...')
    total_sqft = st.number_input('Total Square Feet', value=1000)
    bath = st.number_input('Number of Bathrooms', value=2)
    bhk = st.number_input('Number of Bedrooms (BHK)', value=2)

    # Predict button
    if st.button('Predict Price'):
        # Call the predict_price function
        predicted_price = predict_price(location, total_sqft, bath, bhk)
        st.success(f'Predicted Price: {predicted_price}')

import streamlit as st